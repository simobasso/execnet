==============================================================================
execnet examples
==============================================================================

execnet is under active development.  If you have questions
or ideas or otherwise want to contribute please feel welcome
to join the `execnet-dev`_ mailing list.

.. _`execnet-dev`: http://codespeak.net/mailman/listinfo/execnet-dev

Connect to Python2/Numpy from Python3 
----------------------------------------

Here we run a Python3 interpreter to connect to a Python2.6 interpreter
that has numpy installed. We send items to be added to an array and
receive back the remote "repr" of the array::

    import execnet
    gw = execnet.PopenGateway("python2.6")
    channel = gw.remote_exec("""
        import numpy
        array = numpy.array([1,2,3])
        while 1:
            x = channel.receive()
            if x is None:
                break
            array = numpy.append(array, x)
        channel.send(repr(array))
    """)
    for x in range(10):
        channel.send(x)
    channel.send(None)
    print (channel.receive())

will print on the CPython3.1 side::

    array([1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

A more refined real-life example of python3/python2 interaction 
is the anyvc_ project which uses version-control bindings in 
a Python2 subprocess in order to offer Python3-based library
functionality.

.. _anyvc: http://bitbucket.org/RonnyPfannschmidt/anyvc/overview/

Work with Java objects from CPython
----------------------------------------

Use your CPython interpreter to connect to a Jython_ interpreter
and work with Java types::

    import execnet
    gw = execnet.PopenGateway("jython")
    channel = gw.remote_exec("""
        from java.util import Vector
        v = Vector()
        v.add('aaa')
        v.add('bbb')
        for val in v:
            channel.send(val)
    """)

    for item in channel:
        print (item)

will print on the CPython side::

    aaa
    bbb

.. _Jython: http://www.jython.org

Work with C# objects from CPython
----------------------------------------

(Experimental) use your CPython interpreter to connect to a IronPython_ interpreter
which can work with C# classes.  Here is an example for instantiating
a CLR Array instance and sending back its representation::

    import execnet
    gw = execnet.PopenGateway("ipy")

    channel = gw.remote_exec("""
        import clr
        clr.AddReference("System")
        from System import Array
        array = Array[float]([1,2])
        channel.send(str(array))
    """)
    print (channel.receive())

using Mono 2.0 and IronPython-1.1 this will print on the CPython side::

    System.Double[](1.0, 2.0)

.. note:: 
   Using IronPython needs more testing, likely newer versions
   will work better.  please feedback if you have information. 

.. _IronPython: http://www.IronPython.org

Compare cwd() of Popen Gateways
----------------------------------------

A PopenGateway has the same working directory as the instantiatior::

    >>> import execnet, os
    >>> gw = execnet.PopenGateway()
    >>> ch = gw.remote_exec("import os; channel.send(os.getcwd())")
    >>> res = ch.receive()
    >>> assert res == os.getcwd()

.. _channelexec:

Sending modules with remote_exec 
--------------------------------------------------------------

You can pass a module object to ``remote_exec`` in which case
its source code will be sent.  No dependencies will be transferred
so the module must be self-contained or only use modules that are 
installed on the "other" side.   Module code can detect if it is 
running in a remote_exec situation by checking for the special 
``__name__`` attribute::

    # content of a module remote1.py 

    if __name__ == '__channelexec__':
        channel.send('initialization complete')

You can now send the module like this::

    >>> import execnet, remote1
    >>> gw = execnet.PopenGateway()
    >>> ch = gw.remote_exec(remote1)
    >>> print (ch.receive())

which will print the 'initialization complete' string. 

.. _command:

A simple command pattern 
--------------------------------------------------------------

If you want the remote side to serve a number 
of synchronous function calls, here is a base
implementation::

    # contents of: remotecmd.py 
    def simple(arg): 
        return arg + 1

    if __name__ == '__channelexec__':
        for item in channel:
            funcname = item[0]
            func = globals()[funcname]
            args = item[1:]
            result = func(*args)
            channel.send(result)

Then on the local side you can do::

    >>> import execnet, remotecmd
    >>> gw = execnet.PopenGateway()
    >>> ch = gw.remote_exec(remotecmd) 
    >>> ch.send(('simple', 10)) # execute func-call remotely
    >>> ch.receive()
    11

It's straight forward to build a proxy-object
that would hide the details and perform remote
function calls with basic input and output values.

Synchronously receive results from two sub processes 
-----------------------------------------------------

Use MultiChannels for receiving multiple results from remote code::

    >>> import execnet
    >>> ch1 = execnet.PopenGateway().remote_exec("channel.send(1)")
    >>> ch2 = execnet.PopenGateway().remote_exec("channel.send(2)")
    >>> mch = execnet.MultiChannel([ch1, ch2])
    >>> l = mch.receive_each()
    >>> assert len(l) == 2
    >>> assert 1 in l 
    >>> assert 2 in l 
   
Asynchronously receive results from two sub processes 
-----------------------------------------------------

Use ``MultiChannel.make_receive_queue()`` for asynchronously receiving 
multiple results from remote code.  This standard Queue provides 
``(channel, result)`` tuples which allows to determine where 
a result comes from::

    >>> import execnet
    >>> ch1 = execnet.PopenGateway().remote_exec("channel.send(1)")
    >>> ch2 = execnet.PopenGateway().remote_exec("channel.send(2)")
    >>> mch = execnet.MultiChannel([ch1, ch2])
    >>> queue = mch.make_receive_queue()
    >>> chan1, res1 = queue.get()  # you may also specify a timeout 
    >>> chan2, res2 = queue.get()
    >>> res1 + res2 
    3
    >>> assert chan1 in (ch1, ch2)
    >>> assert chan2 in (ch1, ch2)
    >>> assert chan1 != chan2

Receive file contents from remote SSH account 
-----------------------------------------------------

Here is a small program that you can use to retrieve
contents of remote files::

    import execnet
    # open a gateway to a fresh child process 
    gw = execnet.SshGateway('codespeak.net') 
    channel = gw.remote_exec("""
            for fn in channel:
                f = open(fn, 'rb')
                channel.send(f.read())
                f.close()
    """) 

    for fn in somefilelist: 
        channel.send(fn) 
        content = channel.receive()
        # process content 
     
    # later you can exit / close down the gateway
    gw.exit()


Instantiate a socket server in a new subprocess 
-----------------------------------------------------

The following example opens a PopenGateway, i.e. a python
child process, and starts a socket server within that process 
and then opens a second gateway to the freshly started
socketserver::
                
    import execnet 

    popengw = execnet.PopenGateway()
    socketgw = execnet.SocketGateway.new_remote(popengw, ("127.0.0.1", 0))

    print socketgw._rinfo() # print some info about the remote environment

